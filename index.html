<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Visualizing Sorting Algorithms</title>
	
	<script type="text/javascript">

	var gItemArray = new ItemArray(24);
	var gGraphics = null;
	var timer = null;
	var compareSpeed = 100;
	var swapSpeed = 50;

	window.addEventListener("load", eventWindowLoaded, false);

	function eventWindowLoaded () {
		visualizeAlgorithms();
	}

	function visualizeAlgorithms() {

		var mCanvas = document.getElementById('canvas');

		if (!canvasSupport(mCanvas)) {
			alert("Cannot run graphics because this browser does not support the HTML5 Canvas");
			return;
		}
	
		function canvasSupport(canvas) {
			if (!canvas || !canvas.getContext) return false;
			return true;
		}

		// create a graphics object for the canvas
		gGraphics = new GraphicsControl(mCanvas);

		mCanvas = document.getElementById('canvas1');
		gGraphics.setCanvasLayer(1, mCanvas);

		// create array to be sorted
		gItemArray.create();

		// set click event for sort, reset and new buttons
		document.getElementById('selectionSort').addEventListener("click", function() {
			gItemArray.selectionSort();
		});
		document.getElementById('resetOrder').addEventListener("click", function() {
			gItemArray.reset();
			gGraphics.drawScreen(0);
			gGraphics.clearLayer(1);
		});
		document.getElementById('newValues').addEventListener("click", function() {
			gItemArray.create();
			gGraphics.drawScreen(0);
			gGraphics.clearLayer(1);
		});
		
		gGraphics.drawScreen(0);
	}

	// wrap an array as an object with custom sort methods
	function ItemArray(length) {
		// original order of values for resetting between different sorts
		this.original = new Array();

		// working copy for sorting
		this.elements = new Array();

		// number of elements to store in array
		this.length = length;

		// used to populate the array with a new set of random integers
		this.create = function() {
			this.clearTimer();
			this.original.length = 0;
			this.elements.length = 0;
			for (var i = 0; i < this.length; i++) {
				var value = Math.floor(Math.random() * this.length) + 1;
				this.original.push(value);
				this.elements.push(value);
			}
			this.clearInfo();
		}

		this.clearTimer = function() {
			if (timer !== null) {
				clearTimeout(timer);
				timer = null;
			}
		}

		this.clearInfo = function() {
			document.getElementById('message').innerHTML = "";
			document.getElementById('description').innerHTML = "";
		}

		this.reset = function() {
			this.clearTimer();
			this.elements.length = 0; 

			// assumes this.original's length has not changed from this.length
			for (var i = 0; i < this.length; i++) {
				this.elements.push(this.original[i]);
			}
			this.clearInfo();
		}

		this.selectionSort = function() {
			this.clearTimer();
			document.getElementById('description').innerHTML = "<p>A simple, in-place comparison sort with O(n^2) complexity.  Generally performs worse than insertion sort.</p><p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>";
			document.getElementById('message').innerHTML = 'Running selection sort...';
			
			selSortOuter(-1);			
		}

		return this;
	}

	function selSortOuter(i) {
		i++;
		gGraphics.drawSelectionSort(0, i);
		if (i < gItemArray.length) {
			gGraphics.markSwapBase(0, i);
			timer = setTimeout(function() {selSortInner(i, i, i);}, compareSpeed);
		}
		else {
			document.getElementById('message').innerHTML = 'Selection sort finished.';
			gGraphics.drawSelectionSort(0, i);
		}
	}

	function selSortInner(i, j, min) {
		// change previous 'compare' highlight back to standard
		if (j > 0 && j != min) gGraphics.drawStandard(0, j);

		// highlight current min
		gGraphics.highlightMin(0, min);

		// continue comparisons against current min
		j++;
		if (j < gItemArray.length) {
			gGraphics.showNextCompare(0, j);
			if (gItemArray.elements[j] < gItemArray.elements[min]) {
				gGraphics.drawStandard(0, min);
				min = j;
				gGraphics.highlightMin(0, min);
			}
			timer = setTimeout(function() {selSortInner(i, j, min);}, compareSpeed);
		}
		else {
			if (i !== min) {
				var temp = gItemArray.elements[i];
				gItemArray.elements[i] = gItemArray.elements[min];
				gItemArray.elements[min] = temp;

				gGraphics.swapElements(0, 1, i, min);  // TODO
			} else {
				selSortOuter(i);
			}
		}
	}

	function GraphicsControl(inCanvas) {
		this.canvas = new Array();
		this.context = new Array();

		// set base canvas and context
		this.canvas.push(inCanvas);
		var cxt = this.canvas[0].getContext('2d');
		this.context.push(cxt);

		this.startX = 5;
		this.startY = 130;
		this.maxHeight = 60;
		this.barWd = 6;
		this.labelFnt = "7pt Arial";
		this.lineColor = "black";
		this.stdColor = "blue";
		this.sortedColor = "red";
		this.minColor = "#33ff66";
		this.compareColor = "#33ccff";
		this.openSpotColor = "blue";
		this.arrowWd = 6;
		this.arrowHt = 12;
		this.arrowY = 6;

		this.setCanvasLayer = function(layerNo, canvasId) {
			if (!isNaN(layerNo)) {
				this.canvas.splice(layerNo, 0, canvasId);
				var cxt = this.canvas[layerNo].getContext('2d');
				this.context.splice(layerNo, 0, cxt);
			}
		}

		this.clearLayer = function(layer) {
			this.context[layer].clearRect(0, 0, this.canvas[layer].width, this.canvas[layer].height);
		}

		this.drawScreen = function(layer) {
			this.context[layer].clearRect(0, 0, this.canvas[layer].width, this.canvas[layer].height);

			// draw bars & labels
			for (var i = 0; i < gItemArray.length; i++) {
				this.drawItem(layer, i, this.stdColor);
			}
		}

		this.drawBaseline = function(layer) {
			this.context[layer].beginPath();
			this.context[layer].strokeStyle = this.lineColor;
			this.context[layer].lineWidth = 1;
			this.context[layer].moveTo(this.startX,this.startY+1);
			this.context[layer].lineTo(this.canvas[layer].width - this.startX, this.startY+1);
			this.context[layer].stroke();
			this.context[layer].closePath();
		}

		this.drawSelectionSort = function(layer, switchPt) {
			this.context[layer].clearRect(0, 0, this.canvas[layer].width, this.canvas[layer].height);

			for (var k = 0; k < gItemArray.length; k++) {
				var color = this.stdColor;
				if (k < switchPt) color = this.sortedColor;
				this.drawItem(layer, k, color);
			}
		}

		this.drawItem = function(layer, i, color) {
			this.drawBar(layer, this.calculateX(i), this.startY, this.calculateHt(i), color);
			this.drawLabel(layer, i, color);
			this.drawBaseline(layer);
		}

		this.hideItem = function(layer, i) {
			this.context[layer].clearRect(this.calculateX(i)-this.barWd/2, this.arrowHt + this.arrowY, this.barWd*2, this.startY);
			this.drawBaseline(layer);
		}

		this.calculateX = function(i) {
			return this.startX + this.barWd/2 + (this.barWd * 2 * i);
		}

		this.calculateHt = function(i) {
			return this.maxHeight * (gItemArray.elements[i] / gItemArray.length);
		}

		this.drawBar = function(layer, x, y, ht, color) {
			this.context[layer].clearRect(x, this.arrowHt + this.arrowY, this.barWd, this.startY);
			this.context[layer].beginPath();
			this.context[layer].fillStyle = color;
			this.context[layer].rect(x, y - ht, this.barWd, ht);
			this.context[layer].stroke();
			this.context[layer].fill();
			this.context[layer].closePath();
		}

		this.drawLabel = function(layer, i, color) {
			var x = this.startX + this.barWd/4 + (this.barWd * 2 * i);
			this.context[layer].clearRect(x, this.startY + 1, this.barWd, this.startY);
			this.context[layer].font = color;
			this.context[layer].setTransform(1,0,0,1,0,0);
			this.context[layer].translate(x, this.startY + 12);
			this.context[layer].rotate(270 + (Math.PI / 2));
			this.context[layer].textAlign = "center";
			this.context[layer].translate(0, 0);
			this.context[layer].fillText(gItemArray.elements[i].toString(), 0, 0);
			this.context[layer].rotate(0);
			this.context[layer].setTransform(1,0,0,1,0,0);
		}

		this.markSwapBase = function(layer, i) {
			var x = this.calculateX(i);
			this.drawDownArrow(layer, x, this.arrowY, "black");
		}

		this.clearSwapBaseMark = function(layer) {
			this.context[layer].clearRect(0, 0, this.canvas[layer].width, this.arrowHt);
		}

		this.drawSortedItem = function(layer, i) {
			this.drawItem(layer, i, this.sortedColor);
		}

		this.highlightMin = function(layer, min) {
			this.drawItem(layer, min, this.minColor);
		}

		this.drawStandard = function(layer, i) {
			this.drawItem(layer, i, this.stdColor);
		}

		this.showNextCompare = function(layer, i) {
			this.drawItem(layer, i, this.compareColor);
		}

		this.drawDownArrow = function(layer, x,y,color) {
			var third = this.arrowWd / 3;
			this.context[layer].beginPath();
			this.context[layer].fillStyle = color;
			this.context[layer].strokeStyle = color;
			this.context[layer].translate(x, y);
			this.context[layer].moveTo(third, 0);
			this.context[layer].lineTo(third * 2, 0);
			this.context[layer].lineTo(third * 2, this.arrowHt - this.arrowWd);
			this.context[layer].lineTo(this.arrowWd, this.arrowHt - this.arrowWd);
			this.context[layer].lineTo(this.arrowWd/2, this.arrowHt);
			this.context[layer].lineTo(0, this.arrowHt - this.arrowWd);
			this.context[layer].lineTo(third, this.arrowHt - this.arrowWd);
			this.context[layer].lineTo(third, 0);
			this.context[layer].fill();
			this.context[layer].stroke();
			this.context[layer].translate(-x, -y);
			this.context[layer].closePath();
		}

		this.swapElements = function(baseLayer, swapLayer, i, min) {
			var x1 = this.calculateX(i);
			var x2 = this.calculateX(min);
			/* for first bar's height, use the value from 'min' since they're already swapped in the array.
			Use the value from 'i' for the second bar's height
			*/
			var ht1 = this.calculateHt(min);
			var ht2 = this.calculateHt(i);

			// hide bars being switched in base layer
			this.hideItem(baseLayer, i);
			this.hideItem(baseLayer, min);

			// animate swap
			this.slideBars(swapLayer, "up", x1, x2, i, min, ht1, ht2, 0);
		}

		this.slideBars = function(layer, dir, x1, x2, i, min, ht1, ht2, nComplete) {
			this.clearLayer(layer);

			if (dir == "up") {
				if (nComplete < 5) {
					// draw bars
					gGraphics.drawBar(layer, x1, this.startY - nComplete, ht1, this.openSpotColor);
					gGraphics.drawBar(layer, x2, this.startY - nComplete, ht2, this.minColor);
					timer = setTimeout(function() {gGraphics.slideBars(layer, "up", x1, x2, i, min, ht1, ht2, nComplete+1);}, swapSpeed);
				} else {
					this.slideBars(layer, "side", x1, x2, i, min, ht1, ht2, 0);
				}
			} else if (dir == "side") {
				var range = min - i;
				var y = (nComplete <= range) ? nComplete : 2 * range - nComplete;
				if (nComplete < range * 2) {
					x1 += this.barWd;
					x2 -= this.barWd;
					gGraphics.drawBar(layer, x1, this.startY - 5 - y, ht1, this.openSpotColor);
					gGraphics.drawBar(layer, x2, this.startY - 5 - y, ht2, this.minColor);
					timer = setTimeout(function() {gGraphics.slideBars(layer, "side", x1, x2, i, min, ht1, ht2, nComplete+1);}, swapSpeed);
				} else {
					this.slideBars(layer, "down", x1, x2, i, min, ht1, ht2, 0);
				}
			} else if (dir == "down") {
				if (nComplete < 5) {
					gGraphics.drawBar(layer, x1, this.startY - 5 + nComplete, ht1, this.openSpotColor);
					gGraphics.drawBar(layer, x2, this.startY - 5 + nComplete, ht2, this.minColor);
					timer = setTimeout(function() {gGraphics.slideBars(layer, "down", x1, x2, i, min, ht1, ht2, nComplete+1);}, swapSpeed);
				} else {
					selSortOuter(i);
				}
			}
		}

		return this;
	}

	</script>
	<style>
	body {
		width: 300px;
		margin: 0 auto;
	}
	#canvas {
		position: absolute;
		top: 25px;
		left: 25px;
		border: solid 1px black;
		padding: 0px;
		margin: 0px;
		width: 250px;
		height: 100px;
		background-color: #ffff99;
		z-index: 0;
	}
	#canvas1 {
		position: absolute;
		top: 25px;
		left: 25px;
		border: none;
		padding: 0px;
		margin: 0px;
		width: 250px;
		height: 100px;
		background-color: transparent;
		z-index: 1;
	}
	div#legend {
		margin-top: 130px;
		left: 25px;
		position: absolute;
		display: block;
		width: 100%;
		height: 15px;
		font-size: 0.6em;
	}
	div#legend div {
		display: inline;
	}
	.box {
		border: solid 1px black;
		width: 10px;
		height: 10px;
		float: left;
	}
	#openSpot {
		clear: both;
		display: block;
		left: 25px;
		text-align: left;
		line-height: 2;
	}
	#sorted {
		background-color: red;
	}
	#currMin {
		background-color: #33ff66;
	}
	#currCompare {
		background-color: #33ccff;
	}
	.text {
		width: 70px;
		float: left;
		padding-left: 5px;
	}
	.controls {
		width: 250px;
		position: absolute;
		margin-top: 170px;
		left: 25px;
		border: none;
	}
	button {
		border-radius: 10px;
		line-height: 2;
		text-align: center;
		width: 100px;
		display: inline;
		font-family: sans-serif;
		font-size: 12px;
	}
	fieldset {
		display: block;
		margin-bottom: 10px;
	}
	.sorts legend {
		text-align: center;
	}
	#message {
		display: block;
		background-color: #ffff99;
	}
	#description {
		font-size: .75em;
	}
	</style>
</head>
<body>	
	<canvas id="canvas">Your browser does not support HTML5 Canvas</canvas>
	<canvas id="canvas1"></canvas>
	<div id="legend">
		<div id="sorted" class="box"></div><div class="text">Sorted</div>
		<div id="currMin" class="box"></div><div class="text">Current Min</div>
		<div id="currCompare" class="box"></div><div class="text">Next Compare</div>
		<p id="openSpot">(The black arrow indicates where the next sorted value goes)</p>
	</div>
	<div class="controls">
		<fieldset class="general">
			<button id='newValues'>New Values</button> 
			<button id='resetOrder'>Reset Order</button>
		</fieldset>
		<fieldset class="sorts">
			<legend>Types of Sorts</legend>
			<button id='selectionSort'>Selection Sort</button>
			<button id='bubbleSort'>Bubble Sort</button>
			<button id='insertionSort'>Insertion Sort</button>
			<button id='quickSort'>Quicksort</button>
			<button id='mergeSort'>Merge Sort</button>
			<button id='heapSort'>Heapsort</button>
		</fieldset>
		<div id='message'></div>
		<section id="description"></section>
	</div>
</body>
</html>
