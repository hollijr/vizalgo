<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Visualizing Sorting Algorithms</title>
	
	<script type="text/javascript">

	var gItemArray = new ItemArray(24);
	var gGraphics = null;
	var timer = null;
	
	window.addEventListener("load", eventWindowLoaded, false);

	function eventWindowLoaded () {
		visualizeAlgorithms();
	}

	function visualizeAlgorithms() {

		var mCanvas = document.getElementById('canvas');

		if (!canvasSupport(mCanvas)) {
			alert("Cannot run graphics because this browser does not support the HTML5 Canvas");
			return;
		}
	
		function canvasSupport(canvas) {
			if (!canvas || !canvas.getContext) return false;
			return true;
		}

		// create a graphics object for the canvas
		gGraphics = new GraphicsControl(mCanvas);

		// create array to be sorted
		gItemArray.create();

		// set click event for sort, reset and new buttons
		document.getElementById('selectionSort').addEventListener("click", function() {
			gItemArray.selectionSort();
		});
		document.getElementById('resetOrder').addEventListener("click", function() {
			gItemArray.reset();
			gGraphics.drawScreen();
		});
		document.getElementById('newValues').addEventListener("click", function() {
			gItemArray.create();
			gGraphics.drawScreen();
		});
		
		gGraphics.drawScreen();
	}

	// wrap an array as an object with custom sort methods
	function ItemArray(length) {
		// original order of values for resetting between different sorts
		this.original = new Array();

		// working copy for sorting
		this.elements = new Array();

		// number of elements to store in array
		this.length = length;

		// used to populate the array with a new set of random integers
		this.create = function() {
			this.clearTimer();
			this.original.length = 0;
			this.elements.length = 0;
			for (var i = 0; i < this.length; i++) {
				var value = Math.floor(Math.random() * this.length) + 1;
				this.original.push(value);
				this.elements.push(value);
			}
			this.clearInfo();
		}

		this.clearTimer = function() {
			if (timer !== null) {
				clearTimeout(timer);
				timer = null;
			}
		}

		this.clearInfo = function() {
			document.getElementById('message').innerHTML = "";
			document.getElementById('description').innerHTML = "";
		}

		this.reset = function() {
			this.clearTimer();
			this.elements.length = 0; 

			// assumes this.original's length has not changed from this.length
			for (var i = 0; i < this.length; i++) {
				this.elements.push(this.original[i]);
			}
			this.clearInfo();
		}

		this.selectionSort = function() {
			if (timer !== null) {
				clearTimeout(timer);
				timer = null;
			}
			document.getElementById('description').innerHTML = "<p>A simple, in-place comparison sort with O(n^2) complexity.  Generally performs worse than insertion sort.</p><p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>";
			document.getElementById('message').innerHTML = 'Running selection sort...';
			
			selSortOuter(-1);			
		}

		return this;
	}

	function selSortOuter(i) {
		i++;
		gGraphics.drawSelectionSort(i);
		if (i < gItemArray.length) {
			gGraphics.markSwapBase(i);
			timer = setTimeout(function() {selSortInner(i, i, i);}, 200);
		}
		else {
			document.getElementById('message').innerHTML = 'Finished';
			gGraphics.drawSelectionSort(i);
		}
	}

	function selSortInner(i, j, min) {
		// change previous 'compare' highlight back to standard
		if (j > 0 && j != min) gGraphics.drawStandard(j);

		// highlight current min
		gGraphics.highlightMin(min);

		// continue comparisons against current min
		j++;
		if (j < gItemArray.length) {
			gGraphics.showNextCompare(j);
			if (gItemArray.elements[j] < gItemArray.elements[min]) {
				gGraphics.drawStandard(min);
				min = j;
				gGraphics.highlightMin(min);
			}
			timer = setTimeout(function() {selSortInner(i, j, min);}, 200);
		}
		else {
			if (i !== min) {
				gGraphics.swapElements(i, min);  // TODO
				var temp = gItemArray.elements[i];
				gItemArray.elements[i] = gItemArray.elements[min];
				gItemArray.elements[min] = temp;
			}
			selSortOuter(i);
		}
	}

	function GraphicsControl(canvas) {
		this.canvas = canvas;
		this.context = canvas.getContext('2d');
		this.startX = 5;
		this.startY = 130;
		this.maxHeight = 60;
		this.barWd = 6;
		this.labelFnt = "7pt Arial";
		this.lineColor = "black";
		this.stdColor = "blue";
		this.sortedColor = "red";
		this.minColor = "#33ff66";
		this.compareColor = "#33ccff";
		this.arrowWd = 6;
		this.arrowHt = 12;
		this.arrowY = 6;

		this.drawScreen = function() {
			this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.drawBaseline();

			// draw bars & labels
			for (var i = 0; i < gItemArray.length; i++) {
				this.drawItem(i, this.stdColor);
			}
		}

		this.drawBaseline = function() {
			this.context.beginPath();
			this.context.strokeStyle = this.lineColor;
			this.context.lineWidth = 1;
			this.context.moveTo(this.startX,this.startY);
			this.context.lineTo(this.canvas.width - this.startX, this.startY);
			this.context.stroke();
			this.context.closePath();
		}

		this.drawSelectionSort = function(switchPt) {
			this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.drawBaseline();

			for (var k = 0; k < gItemArray.length; k++) {
				var color = this.stdColor;
				if (k < switchPt) color = this.sortedColor;
				this.drawItem(k, color);
			}
		}

		this.drawItem = function(i, color) {
			this.drawBar(i, color);
			this.drawLabel(i, color);
		}

		this.calculateX = function(i) {
			return this.startX + this.barWd/2 + (this.barWd * 2 * i);
		}

		this.drawBar = function(i, color) {
			var ht = this.maxHeight * (gItemArray.elements[i] / gItemArray.length);
			var x = this.startX + this.barWd/2 + (this.barWd * 2 * i);
			this.context.clearRect(x, this.arrowHt + this.arrowY, this.barWd, this.startY);
			this.context.beginPath();
			this.context.fillStyle = color;
			this.context.rect(x, this.startY - ht, this.barWd, ht);
			this.context.stroke();
			this.context.fill();
			this.context.closePath();
		}

		this.drawLabel = function(i, color) {
			var x = this.startX + this.barWd/4 + (this.barWd * 2 * i);
			this.context.clearRect(x, this.startY + 1, this.barWd, this.startY);
			this.context.font = color;
			this.context.setTransform(1,0,0,1,0,0);
			this.context.translate(x, this.startY + 12);
			this.context.rotate(270 + (Math.PI / 2));
			this.context.textAlign = "center";
			this.context.translate(0, 0);
			this.context.fillText(gItemArray.elements[i].toString(), 0, 0);
			this.context.rotate(0);
			this.context.setTransform(1,0,0,1,0,0);
		}

		this.markSwapBase = function(i) {
			var x = this.calculateX(i);
			this.drawDownArrow(x, this.arrowY, "black");
		}

		this.clearSwapMarks = function() {
			this.context.clearRect(0, 0, this.canvas.width, this.arrowHt);
		}

		this.drawSortedItem = function(i) {
			this.drawItem(i, this.sortedColor);
		}

		this.swapElements = function(openSpot, min) {

		}

		this.highlightMin = function(min) {
			this.drawItem(min, this.minColor);
		}

		this.drawStandard = function(i) {
			this.drawItem(i, this.stdColor);
		}

		this.showNextCompare = function(i) {
			this.drawItem(i, this.compareColor);
		}

		this.drawDownArrow = function(x,y,color) {
			var third = this.arrowWd / 3;
			this.context.beginPath();
			this.context.fillStyle = color;
			this.context.strokeStyle = color;
			this.context.translate(x, y);
			this.context.moveTo(third, 0);
			this.context.lineTo(third * 2, 0);
			this.context.lineTo(third * 2, this.arrowHt - this.arrowWd);
			this.context.lineTo(this.arrowWd, this.arrowHt - this.arrowWd);
			this.context.lineTo(this.arrowWd/2, this.arrowHt);
			this.context.lineTo(0, this.arrowHt - this.arrowWd);
			this.context.lineTo(third, this.arrowHt - this.arrowWd);
			this.context.lineTo(third, 0);
			this.context.fill();
			this.context.stroke();
			this.context.translate(-x, -y);
			this.context.closePath();
		}

		return this;
	}

	</script>
	<style>
	body {
		width: 300px;
		margin: 0 auto;
	}
	#canvas {
		position: absolute;
		top: 25px;
		left: 25px;
		border: solid 1px black;
		padding: 0px;
		margin: 0px;
		width: 250px;
		height: 100px;
		background-color: #ffff99;
	}
	div#legend {
		margin-top: 130px;
		left: 25px;
		position: absolute;
		display: block;
		width: 100%;
		height: 15px;
		font-size: 0.6em;
	}
	div#legend div {
		display: inline;
	}
	.box {
		border: solid 1px black;
		width: 10px;
		height: 10px;
		float: left;
	}
	#openSpot {
		clear: both;
		display: block;
		left: 25;
		text-align: left;
		line-height: 2;
	}
	#sorted {
		background-color: red;
	}
	#currMin {
		background-color: #33ff66;
	}
	#currCompare {
		background-color: #33ccff;
	}
	.text {
		width: 70px;
		float: left;
		padding-left: 5px;
	}
	.controls {
		width: 250px;
		position: absolute;
		margin-top: 170px;
		left: 25px;
		border: none;
	}
	button {
		border-radius: 10px;
		line-height: 2;
		text-align: center;
		width: 100px;
		display: inline;
		font-family: sans-serif;
		font-size: 12px;
	}
	fieldset {
		display: block;
		margin-bottom: 10px;
	}
	.sorts legend {
		text-align: center;
	}
	#message {
		display: block;
		background-color: #ffff99;
	}
	#description {
		font-size: .75em;
	}
	</style>
</head>
<body>	
	<canvas id="canvas">Your browser does not support HTML5 Canvas</canvas>
	<div id="legend">
		<div id="sorted" class="box"></div><div class="text">Sorted</div>
		<div id="currMin" class="box"></div><div class="text">Current Min</div>
		<div id="currCompare" class="box"></div><div class="text">Next Compare</div>
		<p id="openSpot">(The black arrow indicates where the next sorted value goes)</p>
	</div>
	<div class="controls">
		<fieldset class="general">
			<button id='newValues'>New Values</button> 
			<button id='resetOrder'>Reset Order</button>
		</fieldset>
		<fieldset class="sorts">
			<legend>Types of Sorts</legend>
			<button id='selectionSort'>Selection Sort</button>
			<button id='bubbleSort'>Bubble Sort</button>
			<button id='insertionSort'>Insertion Sort</button>
			<button id='quickSort'>Quicksort</button>
			<button id='mergeSort'>Merge Sort</button>
			<button id='heapSort'>Heapsort</button>
		</fieldset>
		<div id='message'></div>
		<section id="description"></section>
	</div>
</body>
</html>
